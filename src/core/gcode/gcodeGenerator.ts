import { Point3D } from '@/types'
import { PrinterSettings, Transform } from '@/stores/gcodeStore'
import { getLayerContourAtZ, getShapeZRange } from '@/core/geometry/shapeSlicers'
import { transformPoint } from '@/core/transforms/transformUtils'
import type { ShapeParameters } from '@/types'

/**
 * Generate GCode from geometry points
 */

export function generateGCodeLine(
  x?: number,
  y?: number,
  z?: number,
  e?: number,
  f?: number,
  comment?: string
): string {
  const parts: string[] = []
  
  if (x !== undefined) parts.push(`X${x.toFixed(3)}`)
  if (y !== undefined) parts.push(`Y${y.toFixed(3)}`)
  if (z !== undefined) parts.push(`Z${z.toFixed(3)}`)
  if (e !== undefined) parts.push(`E${e.toFixed(5)}`)
  if (f !== undefined) parts.push(`F${f.toFixed(0)}`)
  
  let line = parts.join(' ')
  if (comment) {
    line += ` ; ${comment}`
  }
  
  return line
}

export function generateGCodeHeader(settings: PrinterSettings): string[] {
  return [
    '; GCode generated by GCode Generator',
    '; Compatible with BambuStudio',
    ';',
    `; Printer Settings:`,
    `;   Nozzle: ${settings.nozzleDiameter}mm`,
    `;   Layer Height: ${settings.layerHeight}mm`,
    `;   Print Speed: ${settings.printSpeed}mm/s`,
    `;   Filament: ${settings.filamentDiameter}mm`,
    ';',
    'G28 ; Home all axes',
    `M104 S${settings.nozzleTemperature} ; Set nozzle temperature`,
    `M140 S${settings.bedTemperature} ; Set bed temperature`,
    'M190 S0 ; Wait for bed temperature',
    'M109 S0 ; Wait for nozzle temperature',
    'G90 ; Use absolute coordinates',
    'G21 ; Set units to millimeters',
    'G92 E0 ; Reset extruder',
    ';',
  ]
}

export function generateGCodeFooter(): string[] {
  return [
    ';',
    'M104 S0 ; Turn off nozzle',
    'M140 S0 ; Turn off bed',
    'G28 X0 Y0 ; Home X and Y',
    'M84 ; Disable steppers',
    '; End of GCode',
  ]
}

export function generateGCodeFromPoints(
  points: Point3D[],
  settings: PrinterSettings,
  layerHeight: number
): string[] {
  const gcode: string[] = []
  const feedRate = settings.printSpeed * 60 // Convert mm/s to mm/min
  
  // Calculate extrusion per mm (simplified)
  const layerArea = settings.nozzleDiameter * settings.layerHeight
  const filamentArea = Math.PI * Math.pow(settings.filamentDiameter / 2, 2)
  const extrusionMultiplier = layerArea / filamentArea
  
  let currentZ = 0
  let totalExtrusion = 0
  
  // Generate layers
  const maxZ = Math.max(...points.map((p) => p.z))
  const numLayers = Math.ceil(maxZ / layerHeight)
  
  for (let layer = 0; layer < numLayers; layer++) {
    currentZ = layer * layerHeight
    gcode.push(`; Layer ${layer + 1}`)
    gcode.push(`G1 Z${currentZ.toFixed(3)} F${feedRate * 0.5} ; Move to layer`)
    
    // Filter points for this layer
    const layerPoints = points.filter(
      (p) => Math.abs(p.z - currentZ) < layerHeight / 2
    )
    
    if (layerPoints.length > 0) {
      // Move to first point
      const firstPoint = layerPoints[0]
      gcode.push(
        `G1 ${generateGCodeLine(firstPoint.x, firstPoint.y, undefined, undefined, feedRate, 'Move to start')}`
      )
      
      // Generate moves for this layer
      for (let i = 1; i < layerPoints.length; i++) {
        const prev = layerPoints[i - 1]
        const curr = layerPoints[i]
        const distance = Math.sqrt(
          Math.pow(curr.x - prev.x, 2) +
          Math.pow(curr.y - prev.y, 2) +
          Math.pow(curr.z - prev.z, 2)
        )
        const extrusion = distance * extrusionMultiplier
        totalExtrusion += extrusion
        
        gcode.push(
          `G1 ${generateGCodeLine(
            curr.x,
            curr.y,
            curr.z,
            totalExtrusion,
            feedRate,
            `Move ${i}`
          )}`
        )
      }
    }
  }
  
  return gcode
}

export function generateFullGCode(
  points: Point3D[],
  settings: PrinterSettings
): string[] {
  const header = generateGCodeHeader(settings)
  const body = generateGCodeFromPoints(points, settings, settings.layerHeight)
  const footer = generateGCodeFooter()
  
  return [...header, ...body, ...footer]
}

/**
 * Generate GCode by slicing the shape at each layer height.
 * Produces proper layer contours (e.g., circles for cylinder) instead of filtering vertices.
 */
export function generateFullGCodeFromShape(
  shapeParams: ShapeParameters,
  transform: Transform,
  settings: PrinterSettings
): string[] {
  const gcode: string[] = []
  const feedRate = settings.printSpeed * 60
  const layerHeight = settings.layerHeight

  const layerArea = settings.nozzleDiameter * settings.layerHeight
  const filamentArea = Math.PI * Math.pow(settings.filamentDiameter / 2, 2)
  const extrusionMultiplier = layerArea / filamentArea

  const center: Point3D = { x: 0, y: 0, z: 0 }
  const { minZ, maxZ } = getShapeZRange(shapeParams, center)

  // Prepass: find minimum Z of transformed shape so we can offset to z >= 0
  let outputMinZ = Infinity
  for (let z = minZ + layerHeight / 2; z <= maxZ; z += layerHeight) {
    const layerPoints = getLayerContourAtZ(shapeParams, z, center)
    for (const p of layerPoints) {
      const t = transformPoint(p, transform.rotation, transform.scale, transform.translation)
      outputMinZ = Math.min(outputMinZ, t.z)
    }
  }
  const zOffset = outputMinZ < 0 ? -outputMinZ : 0

  let totalExtrusion = 0

  gcode.push(...generateGCodeHeader(settings))

  for (let z = minZ + layerHeight / 2; z <= maxZ; z += layerHeight) {
    const layerPoints = getLayerContourAtZ(shapeParams, z, center)
    if (layerPoints.length === 0) continue

    const transformed = layerPoints.map((p) => {
      const t = transformPoint(p, transform.rotation, transform.scale, transform.translation)
      return { ...t, z: t.z + zOffset }
    })

    const layerZ = transformed[0].z
    const layerIndex = Math.round((z - minZ) / layerHeight)
    gcode.push(`; Layer ${layerIndex + 1}`)
    gcode.push(`G1 Z${layerZ.toFixed(3)} F${feedRate * 0.5} ; Move to layer`)

    gcode.push(
      `G1 ${generateGCodeLine(
        transformed[0].x,
        transformed[0].y,
        undefined,
        undefined,
        feedRate,
        'Move to start'
      )}`
    )

    for (let i = 1; i < transformed.length; i++) {
      const prev = transformed[i - 1]
      const curr = transformed[i]
      const distance = Math.sqrt(
        Math.pow(curr.x - prev.x, 2) +
        Math.pow(curr.y - prev.y, 2) +
        Math.pow(curr.z - prev.z, 2)
      )
      const extrusion = distance * extrusionMultiplier
      totalExtrusion += extrusion

      gcode.push(
        `G1 ${generateGCodeLine(
          curr.x,
          curr.y,
          curr.z,
          totalExtrusion,
          feedRate,
          `Move ${i}`
        )}`
      )
    }
  }

  gcode.push(...generateGCodeFooter())
  return gcode
}
